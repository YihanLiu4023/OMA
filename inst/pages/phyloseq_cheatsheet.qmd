# phyloseq vs TreeSE cheatsheet {#sec-extras}

```{r}
#| label: setup
#| echo: false

knitr::opts_chunk$set(eval=TRUE, warning=FALSE, message=FALSE)
```

This section has a cheatsheet for translating common functions in phyloseq
to TreeSE/mia with example code.

```{r}
#| label: download_libs

# Download libraries
library(mia)
library(phyloseq)
library(dplyr)
library(ggplot2)
```

Start by loading data as a `phyloseq` object "phy" and as `TreeSE` object "tse".

```{r}
#| label: load_data

# Loading example data
# Using GlobalPatterns dataset

data(package = "phyloseq", "GlobalPatterns") # phyloseq object
phy <- GlobalPatterns # Rename
phy # Check the phyloseq object

data(package = "mia", "GlobalPatterns") # TreeSE object
tse <- GlobalPatterns # Rename
tse # Check the tse object
```

## Accessing different types of data in `phyloseq` versus `TreeSE`

Often microbiome datasets contain three different types of tables, one which
defines the microbes' taxonomy from domain to species level, one that
describes sample level information like whether the sample is from a
healthy or a diseased person, and one that has the abundances of taxa from
mapping, like an OTU table.

There are slightly different names for these tables in phyloseq and tse,
but they can be retrieved from the phyloseq and tse containers in analogous
ways.

**Accessing the table of taxonomic names: tax_table = rowData**

phyloseq and TreeSE objects' taxonomy tables can be accessed with tax_table and
rowData commands.

```{r}
#| label: access_data

phy_taxtable <-
    tax_table(phy)  |> # Access the phyloseq taxonomic name table
    data.frame() # Make into a data frame

tse_taxtable <- rowData(tse) |> # Same for tse
    data.frame()

```

**Accessing sample data: sample_data = colData**

Sample data can be accessed with `sample_data` and `colData` commands.

```{r}
#| label: access_sampledata

phy_sampledata <-
    sample_data(phy) |> data.frame()

tse_sampledata <-
    colData(tse) |> data.frame()
```

**Accessing operational taxonomic unit (OTU) abundance objects: otu_table = assay**

OTU tables can be accessed with otu_table and assay commands. The assay can
also hold other types of information like taxa abundances from shotgun
metagenomic annotation, or functional gene abundances.

```{r}
#| label: access_otutable

phy_otutable <-
    otu_table(phy) |> data.frame()

tse_otutable <-
    assay(tse) |> data.frame()
```

## Building phyloseq objects vs TreeSE objects: phyloseq = TreeSummarizedExperiment

After learning how to access various data types from TreeSE, let's see how
creating TreeSE objects compares to creating phyloseq objects. We will use
the vanilla dataframes we created from the phyloseq object to demonstrate
making both types of data objects. These are identical to the equivalent tse
dataframes but for demonstration we will use ones created from phy.

Let's start by checking what we have.

```{r}
#| label: inspect_data

phy_otutable |> head()
phy_sampledata |> head()
phy_taxtable |> head()
```

Ok, these are all normal data frames which could come from upstream
bioinformatics, like OTU tables that come from 16S analysis, and taxonomy
tables.

Let's demo how to create the TreeSE object, how it compares to creating
phyloseq and how assay in TreeSE compares to otu_table in phyloseq.

```{r}
#| label: build_dataobjects


# Create phyloseq object
OTU_phy <- otu_table(as.matrix(phy_otutable), taxa_are_rows = TRUE) # Make OTU table
TAX_phy <- tax_table(as.matrix(phy_taxtable)) # Make TAX table
SAMPLE_phy <- sample_data(phy_sampledata) # Make sample data table

phy <- phyloseq(OTU_phy, TAX_phy, SAMPLE_phy) # Combine into phyloseq object
phy # Inspect

```

Let's start by checking our otu table, and see if it is counts or already
normalized. We will use the same data frame extracted from the phy object
as before.

```{r}
#| label: check_otutable

# Check if we have counts or normalized data

phy_otutable |> head()
```

We have counts!

Since TreeSEs can hold many different versions of the OTU table, most commonly
either relative abundances or counts, we will need to give our assay
(which corresponds to otu_table in Phyloseq) a name and
list the different types of assays or transformations we have. In this
example we only have one item 'counts' in the list.

Let's convert the data frame to a matrix and make the list of assays.

```{r}
#| label: create_tse

# Create TreeSE
counts <- as.matrix(phy_otutable) # Convert to a matrix
assays <- SimpleList(counts = counts)
tse <- TreeSummarizedExperiment(
    assays = assays,
    colData = phy_sampledata,
    rowData = phy_taxtable
)
```

Let's check the different assay names we have.

```{r}
#| label: check_assays
 
assayNames(tse)
```


## Handling different OTU table normalizations in phyloseq vs TreeSE

Adding the assays as a list might seem inconvenient if you only have one type of
OTU table (`counts` in our example), but let's see why it is actually very
convenient to be able to hold multiple assays in one data object. 


Here we'll show an example of how to add relative abundances and CLR normalized
OTU tables to your tse assays.

With phyloseq you would need three different phyloseq objects, each taking up
7.7 MB of memory, whilst the tse with the three assays takes up only 18.3 MB.

```{r}
#| label: transform_assay

# Add another assay that holds the relative abundance normalized OTU table
tse <- transformAssay(tse, assay.type = "counts", method = "relabundance")
assays(tse) # Let's check

# With phyloseq you would need to have two different phyloseq objects
phy_relab  = transform_sample_counts(phy, function(x)
  x / sum(x))

# Let's add clr transformed data just for the fun of it :)
tse <- transformAssay(
    tse,
    assay.type = "counts",
    method = "clr",
    pseudocount = 1)

assays(tse) # Let's check

# With phyloseq you would need to have a third phyloseq object.
# phy_CLR <- microbiome::transform(phy, 'clr') # Example, don't run
```

## Subsetting samples and taxa

**Subsetting samples: subset_samples = indexing columns**

Next let's learn how to subset samples. In phyloseq we use subset_samples
command, but since the sample data is stored in columns in the TreeSe, we
can access it by indexing columns.

In this section we will remove the "Mock" samples and make new data objects.

```{r}
#| label: subset_samples

phy_nomock <- subset_samples(
    phy, !SampleType == "Mock") # Removing mock samples in phyloseq

tse_nomock <- tse[,!tse$SampleType == "Mock"] # tse uses indexing columns
```

Let's see what we have now.

```{r}
#| label: check_removed_samples

phy |> sample_names() |> length()
phy_nomock |> sample_names() |> length()
colnames(tse) |> length()
colnames(tse_nomock) |> length()
```

We have removed three samples that where SampleType "Mock".

**Subsetting taxa: subset_taxa = indexing rows**

Taxa are stored in rows in TreeSE and the TreeSE equivalent to subset_taxa is
indexing rows.

```{r}
#| label: take_only_bact

phy_nomock_bacteria <-
  subset_taxa(phy_nomock, Kingdom == "Bacteria")
tse_nomock_bacteria <-
  tse[tse$Kingdom == "Bacteria", ]

phy_nomock_bacteria # We have 19008 taxa (only bacteria) and before 19216
tse_nomock_bacteria
```

## Calculating alpha diversity: estimate_richness = estimateDiversity

Now we know how data stored in `TreeSE` can be accessed and the `TreeSE` data
objects created. Let's look at how we can calculate alpha diversity using
 `mia` compared to  `phyloseq` package.

The `mia` command  `estimateDiversity()` will return a TreeSE and the results are
stored in `colData`, unlike the `phyloseq` command that outputs a data frame with
just the diversity estimates.

In `phyloseq` you would need to add the alpha diversity separately to your
sample data to keep it safe with the other sample level data.

```{r}
#| label: alpha_div

# Alpha diversity with phyloseq
df <- estimate_richness(phy, measures = "Shannon")
df |> head() # Inspect

# Add Shannon to the sample_data to keep results safe with other sample data
phy_sampledata <- sample_data(phy) |> data.frame()
phy_sampledata$shannon <- df$Shannon
sample_data(phy) <- phy_sampledata
sample_data(phy) |> head()  # Inspect
```

For the tse we will need to specify which assay (which normalization of the
OTU table) we want to use, since we have three options now with the counts,
relative abundance and CLR. We can check the assay names first.

```{r}
#| label: mia_alpha_div

assayNames(tse) # Check the assay names

tse <- estimateDiversity(tse, assay.type = "counts", index = "shannon") # Let's use counts
# Inspect the new colData with added alpha diversity estimate
colData(tse) |> names() # shannon has been added to the colData
```

If we want to extract a data frame that only has the alpha diversity it can be
done easily.

```{r}
#| label: extract_alpha

# Extract
df <- colData(tse) |> data.frame() |> dplyr::select(matches("shannon"))
```

## Calculating beta diversity: ordinate = addMDS

We can calculate PCoA with Bray-Curtis distances in `phyloseq` using the
`ordinate()` command. The beta diversity calculation in `mia` outputs a TreeSE
with a new type of data, reduced dimensions or `reducedDim`. 

Here we will use the `scater` package that runs the PCoA with `addMDS()`. (PCoA and
MDS mean the same thing)

In `phyloseq` you would again need to add the dimensions to the sample data if you
want to keep them safe with other metadata.

```{r}
#| label: beta_div

# Run PCoA on the relative abundance data and store in phy_ord list
phy_ord <- ordinate(phy_relab, method = "PCoA", distance = "bray")

library(scater)

# Ordinate with addMDS and implement the vegan's Bray-Curtis dissimilarity
# distance calculation
tse <- addMDS(
    tse,
    FUN = getDissimilarity,
    method = "bray",
    assay.type = "relabundance",
    name = "MDS_bray",
    ncomponents = 10) # Let's also define how many dimensions
tse # Inspect, now we have new reducedDim "MDS_bray"

```

## Plotting ordinations: `plot_ordination()` = `plotReducedDim()`
`phyloseq` has it's own plotting fuction for ordinations.

```{r}
#| label: plot_ord

plot_ordination(physeq = phy, ordination = phy_ord, color = "SampleType")
```

It is also easy to plot the ordination stored in `reducedDim` in the tse using
the `plotReducedDim()` function. We can first check what the name of the
Bray-Curtis MDS/PCoA was incase we forgot.

```{r}
#| label: check_reducedDimNames

# Check reduced dim names
reducedDimNames(tse)
```
Ok, let's plot.

```{r}
#| label: plot_red_dim

# Plot
plotReducedDim(tse, "MDS_bray", color_by = "SampleType")
# The sign is given arbitrarily. We can change it to match the plot_ordination
reducedDim(tse)[, 1] <- -reducedDim(tse)[, 1]
reducedDim(tse)[, 2] <- -reducedDim(tse)[, 2]
plotReducedDim(tse, "MDS_bray", color_by = "SampleType")
```

## Agglomerating taxa: `tax_glom()` = `agglomerateByRank()`

Often you might want to study your data using different taxonomic ranks,
for example check if you see differences in the abundances of higher
taxonomic levels.

```{r}
#| label: tax_glom

phy_fam <- tax_glom(phy, taxrank = "Family")
```

This family level data object can again be conveniently stored in a tse object
under `altExp`.

`tax_glom()` removes the taxa which have not been assigned to the level given in
taxrank by default (NArm = TRUE).
So we will add the na.rm = TRUE to `agglomerateByRank()` function which is
equivalent to the default behaviour of `tax_glom()`.

```{r}
#| label: agglomerateByRank

altExp(tse, "Family") <- agglomerateByRank(tse, rank = "Family")
altExp(tse, "Family")
```

## Cheatsheet

```{r}
#| label: cheatsheet
#| echo: false

library(knitr)
df <-
  data.frame(
    Functionality = c(
      "Access sample data", # Row 1
      "Access tax table", # Row 2
      "Access OTU table",
      "Build data object",
      "Calculate alpha diversity",
      "Calculate beta diversity",
      "Plot ordination",
      "Subset taxa",
      "Subset samples",
      "Aggromerate taxa"
    ),
    phyloseq = c(
      "sample_data()",
      "tax_table()",
      "otu_table()",
      "phyloseq()",
      "estimate_richness()",
      "ordinate()",
      "plot_ordination()",
      "subset_taxa()",
      "subset_samples()",
      "tax_glom()"
    ),
    "mia/TreeSE" = c(
      "Index columns",
      "Index rows",
      "assays()",
      "TreeSummarizedExperiment()",
      "estimateDiversity()",
      "addMDS()",
      "plotReducedDim()",
      "Index rows",
      "Index columns",
      "agglomerateByRank()"
    )
  )

df2 <- data.frame(
    Data_type = c(
        "OTU table", # Row 1
        "Taxonomy table", # Row2
        "Sample data table"), # Row 3
    phyloseq = c(
        "otu_table", # Row 1
        "tax_table", # Row2
        "sample_data"),# Row 3
    TreeSE = c(
        "assay", # Row 1
        "rowData", # Row2
        "colData") # Row 3
  )

kable(df)
kable(df2)
```

